// src/lib/services/UnitGenerator.ts
import mustache from 'mustache';

export interface GeneratedUnit {
  /** The main systemd unit file name (e.g., "myservice.kube" or "myservice.container") */
  unitFilename: string;
  /** The content of the unit file */
  unitContent: string;
  /** Optional auxiliary files (e.g., the K8s YAML for a .kube unit) */
  auxiliaryFiles: { filename: string; content: string }[];
}

export interface GeneratorOptions {
  name: string;
  templateContent: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  variables: Record<string, any>;
  type: 'kube' | 'container';
}

export class UnitGenerator {
  
  static generate(options: GeneratorOptions): GeneratedUnit {
    const { name, templateContent, variables, type } = options;

    // 1. Render the template (YAML or Container config)
    // Disable escaping for YAML content
    const renderedContent = mustache.render(templateContent, variables);

    if (type === 'kube') {
      return this.generateKube(name, renderedContent);
    } else {
      return this.generateContainer(name, renderedContent);
    }
  }

  private static generateKube(name: string, yamlContent: string): GeneratedUnit {
    const yamlFilename = `${name}.yml`;
    const kubeFilename = `${name}.kube`;
    
    // Minimal standard .kube Quadlet
    const kubeContent = `# Generated by ServiceBay
[Unit]
Description=${name} Kubernetes Pod
After=network-online.target
Wants=network-online.target

[Kube]
Yaml=${yamlFilename}
# Map ports from host to container automatically if specified in YAML
# PublishPort=... (Parsed from YAML if needed, but Podman usually handles hostPort in YAML)

[Install]
WantedBy=default.target
`;

    return {
      unitFilename: kubeFilename,
      unitContent: kubeContent,
      auxiliaryFiles: [
        { filename: yamlFilename, content: yamlContent }
      ]
    };
  }

  private static generateContainer(name: string, containerConfig: string): GeneratedUnit {
    // Assuming the templateContent IS the .container file body
    const filename = `${name}.container`;
    
    // Ensure basic headers if missing? Or assume template is full?
    // Let's assume template provides [Container] section.
    // We might want to prepend a standard header though.
    const content = `# Generated by ServiceBay
${containerConfig}

[Install]
WantedBy=default.target
`;

    return {
      unitFilename: filename,
      unitContent: content,
      auxiliaryFiles: []
    };
  }
}
